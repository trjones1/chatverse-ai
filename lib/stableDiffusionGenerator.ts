import { ImageGenerationProvider, GenerationResult } from '../types/imageGeneration';
import { faceAnalyzer, FaceSimilarityResult } from './faceAnalysis';
import sharp from 'sharp';

export interface StableDiffusionOptions {
  prompt: string;
  negativePrompt?: string;
  width?: number;
  height?: number;
  steps?: number;
  cfgScale?: number;
  seed?: number;
  sampler?: string;
  model?: string;
  // Face-specific options
  faceReferenceImage?: Buffer;
  faceConsistencyStrength?: number;
  generateMultiple?: number;
  useImageToImage?: boolean;
  denoisingStrength?: number;
}

export interface MultiGenerationResult extends GenerationResult {
  candidates: Array<{
    imageData: Buffer;
    similarity: number;
    confidence: number;
    metadata: any;
  }>;
  bestCandidate: {
    imageData: Buffer;
    similarity: number;
    confidence: number;
    metadata: any;
  };
}

export class StableDiffusionGenerator implements ImageGenerationProvider {
  private baseUrl: string;
  private model: string;

  constructor(baseUrl: string = 'http://127.0.0.1:7860', model: string = 'realisticVisionV60B1_v51HyperVAE.safetensors') {
    this.baseUrl = baseUrl;
    this.model = model;
  }

  async generate(prompt: string, options: any = {}): Promise<GenerationResult> {
    const sdOptions = this.processOptions(options);
    
    // If we have a face reference and multiple generation is requested
    if (sdOptions.faceReferenceImage && sdOptions.generateMultiple && sdOptions.generateMultiple > 1) {
      return await this.generateMultipleWithFaceConsistency(sdOptions);
    }
    
    // If we have a face reference and want image-to-image
    if (sdOptions.faceReferenceImage && sdOptions.useImageToImage) {
      return await this.generateImageToImageWithFace(sdOptions);
    }
    
    // Standard generation with face reference
    if (sdOptions.faceReferenceImage) {
      return await this.generateWithFaceReference(sdOptions);
    }
    
    // Standard text-to-image generation
    return await this.generateTextToImage(sdOptions);
  }

  /**
   * Method 1: Face Reference Integration
   * Uses ControlNet or similar to maintain face consistency
   */
  private async generateWithFaceReference(options: StableDiffusionOptions): Promise<GenerationResult> {
    try {
      console.log('üéØ Generating with face reference integration...');
      
      const faceReferenceBase64 = `data:image/png;base64,${options.faceReferenceImage!.toString('base64')}`;
      
      const payload = {
        prompt: options.prompt,
        negative_prompt: options.negativePrompt || this.getDefaultNegativePrompt(),
        width: options.width || 512,
        height: options.height || 512,
        steps: options.steps || 25,
        cfg_scale: options.cfgScale || 7,
        sampler_index: options.sampler || 'DPM++ 2M Karras',
        seed: options.seed || -1,
        // ControlNet configuration for face reference
        alwayson_scripts: {
          controlnet: {
            args: [
              {
                enabled: true,
                input_image: faceReferenceBase64,
                module: 'canny', // or 'openpose_face' if available
                model: 'control_v11p_sd15_canny', // adjust based on available models
                weight: options.faceConsistencyStrength || 0.8,
                resize_mode: 1,
                lowvram: false,
                processor_res: 512,
                threshold_a: 50,
                threshold_b: 200,
                guidance_start: 0.0,
                guidance_end: 1.0,
                control_mode: 0,
                pixel_perfect: false,
              }
            ]
          }
        }
      };

      const response = await fetch(`${this.baseUrl}/sdapi/v1/txt2img`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(`SD API error: ${response.status} - ${response.statusText}`);
      }

      const result = await response.json();
      
      if (!result.images || result.images.length === 0) {
        throw new Error('No images generated by Stable Diffusion');
      }

      const imageBuffer = Buffer.from(result.images[0], 'base64');
      
      // Analyze face consistency
      const similarity = await this.analyzeFaceConsistency(options.faceReferenceImage!, imageBuffer);
      
      console.log(`‚úÖ Generated with face reference (similarity: ${(similarity.similarity * 100).toFixed(1)}%)`);

      return {
        imageData: imageBuffer,
        success: true,
        metadata: {
          provider: 'stable-diffusion',
          method: 'face-reference-integration',
          faceSimilarity: similarity,
          parameters: payload,
        }
      };

    } catch (error) {
      console.error('‚ùå Face reference generation failed:', error);
      
      // Fallback to standard generation
      return await this.generateTextToImage({
        ...options,
        faceReferenceImage: undefined // Remove reference to avoid infinite recursion
      });
    }
  }

  /**
   * Method 2: Image-to-Image Generation with Face Reference
   * Uses the reference image as a starting point and modifies it
   */
  private async generateImageToImageWithFace(options: StableDiffusionOptions): Promise<GenerationResult> {
    try {
      console.log('üñºÔ∏è Generating with image-to-image face preservation...');
      
      const initImageBase64 = `data:image/png;base64,${options.faceReferenceImage!.toString('base64')}`;
      
      const payload = {
        init_images: [initImageBase64],
        prompt: options.prompt,
        negative_prompt: options.negativePrompt || this.getDefaultNegativePrompt(),
        width: options.width || 512,
        height: options.height || 512,
        steps: options.steps || 25,
        cfg_scale: options.cfgScale || 7,
        denoising_strength: options.denoisingStrength || 0.7,
        sampler_index: options.sampler || 'DPM++ 2M Karras',
        seed: options.seed || -1,
      };

      const response = await fetch(`${this.baseUrl}/sdapi/v1/img2img`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(`SD API error: ${response.status} - ${response.statusText}`);
      }

      const result = await response.json();
      
      if (!result.images || result.images.length === 0) {
        throw new Error('No images generated by Stable Diffusion');
      }

      const imageBuffer = Buffer.from(result.images[0], 'base64');
      
      // Analyze face consistency
      const similarity = await this.analyzeFaceConsistency(options.faceReferenceImage!, imageBuffer);
      
      console.log(`‚úÖ Generated with img2img (similarity: ${(similarity.similarity * 100).toFixed(1)}%)`);

      return {
        imageData: imageBuffer,
        success: true,
        metadata: {
          provider: 'stable-diffusion',
          method: 'image-to-image-face-preservation',
          faceSimilarity: similarity,
          parameters: payload,
        }
      };

    } catch (error) {
      console.error('‚ùå Image-to-image generation failed:', error);
      
      // Fallback to face reference method
      return await this.generateWithFaceReference({
        ...options,
        useImageToImage: false
      });
    }
  }

  /**
   * Method 3: Multiple Generation with Face Similarity Selection
   * Generates multiple candidates and selects the best face match
   */
  private async generateMultipleWithFaceConsistency(options: StableDiffusionOptions): Promise<MultiGenerationResult> {
    try {
      console.log(`üé≤ Generating ${options.generateMultiple} candidates for face consistency selection...`);
      
      const generateCount = Math.min(options.generateMultiple || 4, 8); // Limit to 8 max
      const candidates: Array<{
        imageData: Buffer;
        similarity: number;
        confidence: number;
        metadata: any;
      }> = [];

      // Generate multiple images in parallel with different seeds
      const promises = [];
      for (let i = 0; i < generateCount; i++) {
        const seed = options.seed && options.seed > 0 ? options.seed + i : -1;
        promises.push(this.generateSingleCandidate(options, seed, i));
      }

      const results = await Promise.allSettled(promises);
      
      // Process successful results
      for (const result of results) {
        if (result.status === 'fulfilled') {
          candidates.push(result.value);
        }
      }

      if (candidates.length === 0) {
        throw new Error('No candidates generated successfully');
      }

      // Sort by similarity score
      candidates.sort((a, b) => b.similarity - a.similarity);
      
      const bestCandidate = candidates[0];
      
      console.log(`‚úÖ Selected best candidate (similarity: ${(bestCandidate.similarity * 100).toFixed(1)}%)`);
      console.log(`üìä All candidates: ${candidates.map((c, i) => `#${i+1}: ${(c.similarity * 100).toFixed(1)}%`).join(', ')}`);

      return {
        imageData: bestCandidate.imageData,
        success: true,
        candidates,
        bestCandidate,
        metadata: {
          provider: 'stable-diffusion',
          method: 'multiple-generation-face-selection',
          totalCandidates: generateCount,
          successfulCandidates: candidates.length,
          selectionCriteria: 'face-similarity',
        }
      };

    } catch (error) {
      console.error('‚ùå Multiple generation failed:', error);
      
      // Fallback to single generation with face reference
      const fallback = await this.generateWithFaceReference({
        ...options,
        generateMultiple: 1
      });
      
      return {
        ...fallback,
        candidates: [],
        bestCandidate: {
          imageData: fallback.imageData!,
          similarity: 0.5,
          confidence: 0.5,
          metadata: fallback.metadata
        }
      } as MultiGenerationResult;
    }
  }

  private async generateSingleCandidate(options: StableDiffusionOptions, seed: number, index: number) {
    try {
      const payload = {
        prompt: options.prompt,
        negative_prompt: options.negativePrompt || this.getDefaultNegativePrompt(),
        width: options.width || 512,
        height: options.height || 512,
        steps: options.steps || 20, // Slightly fewer steps for speed
        cfg_scale: options.cfgScale || 7,
        sampler_index: options.sampler || 'DPM++ 2M Karras',
        seed: seed,
      };

      const response = await fetch(`${this.baseUrl}/sdapi/v1/txt2img`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(`SD API error for candidate ${index}: ${response.status}`);
      }

      const result = await response.json();
      
      if (!result.images || result.images.length === 0) {
        throw new Error(`No image generated for candidate ${index}`);
      }

      const imageBuffer = Buffer.from(result.images[0], 'base64');
      
      // Analyze face consistency if reference is available
      let similarity = { similarity: 0.5, confidence: 0.5 };
      if (options.faceReferenceImage) {
        similarity = await this.analyzeFaceConsistency(options.faceReferenceImage, imageBuffer);
      }
      
      console.log(`üéØ Candidate ${index + 1}: similarity ${(similarity.similarity * 100).toFixed(1)}%`);

      return {
        imageData: imageBuffer,
        similarity: similarity.similarity,
        confidence: similarity.confidence,
        metadata: {
          candidateIndex: index,
          seed: payload.seed,
          parameters: payload,
        }
      };

    } catch (error) {
      console.warn(`‚ö†Ô∏è Candidate ${index} failed:`, error);
      throw error;
    }
  }

  private async generateTextToImage(options: StableDiffusionOptions): Promise<GenerationResult> {
    try {
      console.log('üìù Generating with text-to-image...');
      
      const payload = {
        prompt: options.prompt,
        negative_prompt: options.negativePrompt || this.getDefaultNegativePrompt(),
        width: options.width || 512,
        height: options.height || 512,
        steps: options.steps || 25,
        cfg_scale: options.cfgScale || 7,
        sampler_index: options.sampler || 'DPM++ 2M Karras',
        seed: options.seed || -1,
      };

      const response = await fetch(`${this.baseUrl}/sdapi/v1/txt2img`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(`SD API error: ${response.status} - ${response.statusText}`);
      }

      const result = await response.json();
      
      if (!result.images || result.images.length === 0) {
        throw new Error('No images generated by Stable Diffusion');
      }

      const imageBuffer = Buffer.from(result.images[0], 'base64');
      
      console.log('‚úÖ Generated with standard text-to-image');

      return {
        imageData: imageBuffer,
        success: true,
        metadata: {
          provider: 'stable-diffusion',
          method: 'text-to-image',
          parameters: payload,
        }
      };

    } catch (error) {
      console.error('‚ùå Text-to-image generation failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        metadata: {
          provider: 'stable-diffusion',
          method: 'text-to-image',
        }
      };
    }
  }

  private async analyzeFaceConsistency(referenceBuffer: Buffer, generatedBuffer: Buffer): Promise<FaceSimilarityResult> {
    try {
      return await faceAnalyzer.compareFaces(referenceBuffer, generatedBuffer);
    } catch (error) {
      console.warn('Face consistency analysis failed:', error);
      return {
        similarity: 0.5,
        confidence: 0.3,
        analysis: {
          reference: { confidence: 0.3 },
          generated: { confidence: 0.3 },
        }
      };
    }
  }

  private processOptions(options: any): StableDiffusionOptions {
    return {
      prompt: options.prompt || '',
      negativePrompt: options.negativePrompt,
      width: options.width || 512,
      height: options.height || 512,
      steps: options.steps || 25,
      cfgScale: options.cfgScale || 7,
      seed: options.seed,
      sampler: options.sampler || 'DPM++ 2M Karras',
      model: options.model || this.model,
      faceReferenceImage: options.faceReferenceImage,
      faceConsistencyStrength: options.faceConsistencyStrength || 0.8,
      generateMultiple: options.generateMultiple || 1,
      useImageToImage: options.useImageToImage || false,
      denoisingStrength: options.denoisingStrength || 0.7,
    };
  }

  private getDefaultNegativePrompt(): string {
    return 'blurry, low quality, distorted face, deformed, ugly, bad anatomy, disfigured, poorly drawn face, mutation, mutated, extra limb, ugly, disgusting, poorly drawn hands, missing limb, floating limbs, disconnected limbs, malformed hands, blurry, ((((mutated hands and fingers)))), watermark, oversaturated, censored, distorted hands, amputation, missing hands, obese, doubled face, double hands, worst quality, low quality, jpeg artifacts';
  }

  /**
   * Check if the WebUI is available
   */
  async isAvailable(): Promise<boolean> {
    try {
      const response = await fetch(`${this.baseUrl}/docs`, { 
        method: 'GET',
        signal: AbortSignal.timeout(5000)
      });
      return response.ok;
    } catch (error) {
      return false;
    }
  }

  /**
   * Get available models
   */
  async getModels(): Promise<string[]> {
    try {
      const response = await fetch(`${this.baseUrl}/sdapi/v1/sd-models`);
      if (!response.ok) return [];
      
      const models = await response.json();
      return models.map((model: any) => model.title);
    } catch (error) {
      console.warn('Failed to fetch models:', error);
      return [];
    }
  }

  /**
   * Switch model
   */
  async switchModel(modelName: string): Promise<boolean> {
    try {
      const response = await fetch(`${this.baseUrl}/sdapi/v1/options`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          sd_model_checkpoint: modelName,
        }),
      });
      
      if (response.ok) {
        this.model = modelName;
        return true;
      }
      return false;
    } catch (error) {
      console.error('Model switching failed:', error);
      return false;
    }
  }
}

export const stableDiffusionGenerator = new StableDiffusionGenerator();